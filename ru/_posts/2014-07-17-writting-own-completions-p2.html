---
category: ru
type: paper
hastr: true
layout: paper
tags: linux, разработка
title: Написание своих дополнений для Shell. Bash
short: writting-own-completions-p2
description: <img hspace=10 vspace=10 align="right" src="/resources/papers/bash_completion.png"> В данных статьях описываются некоторые основы создания файлов дополнений для собственной программы.
---
<h2><a name="preamble" class="anchor" href="#preamble"><span class="octicon octicon-link"></span></a>Преамбула</h2>
<p>В процессе разработки <a href="/ru/projects/netctl-gui">одного своего проекта</a> возникло желание добавить также файлы дополнений (только не спрашивайте зачем). Благо я как-то уже брался за написание подобных вещей, но читать что-либо тогда мне было лень, и так и не осилил.</p>

<h2><a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Введение</h2>
<p>Bash, в <a href="/ru/2014/07/17/writting-own-completions-p1">отличие от zsh</a>, требует к себе некоторого велосипедостроения в отношении дополнений. Бегло погуглив, я не нашел более-менее нормальных туториалов, потому за основу были взяты имеющиеся в системе файлы дополнений для <code>pacman</code>.</p>

<p>Рассмотрим на примере все того же моего приложения. Я напомню, что часть справки к которому выглядит таким образом:</p>

{% highlight bash %}
netctl-gui [ -h | --help ] [ -e ESSID | --essid ESSID ] [ -с FILE | --config FILE ]
           [ -o PROFILE | --open PROFILE ] [ -t NUM | --tab NUM ] [ --set-opts OPTIONS ]
{% endhighlight %}

<p>Список флагов:
<ul>
  <li>флаги <code>-h</code> и <code>--help</code> не требуют аргументов;</li>
  <li>флаги <code>-e</code> и <code>--essid</code> требуют аргумента в виде строки, без дополнения;</li>
  <li>флаги <code>-c</code> и <code>--config</code> требуют аргумента в виде строки, файл с произвольной локацией;</li>
  <li>флаги <code>-o</code> и <code>--open</code> требуют аргумента в виде строки, дополнение по файлам из определенной директории;</li>
  <li>флаги <code>-t</code> и <code>--tab</code> требуют аргумента в виде строки, дополнение из указанного массива;</li>
  <li>флаг <code>--set-opts</code> требует аргумента в виде строки, дополнение из указанного массива, разделены запятыми;</li>
</ul>
</p>

<h2><a name="file" class="anchor" href="#file"><span class="octicon octicon-link"></span></a>Структура файла</h2>
<p>Здесь <b>все</b> переменные должны возвращать массив. Каких-либо особых форматов тут уже нет. Сначала опишем флаги, потом уже все остальные переменные. Я напомню (так как ниже я уже не буду приводить функции более подробно), что <code>_netctl_profiles()</code>, в отличие от других переменных, должна возвращать актуальный на данный момент массив:

{% highlight bash %}
# variables
_netctl_gui_arglist=()
_netctl_gui_settings=()
_netctl_gui_tabs=()
_netctl_profiles() {}
{% endhighlight %}

Затем идут основные функции, которые будут вызываться для дополнения для определенной команды. В моем случае команда одна, и функция одна:

{% highlight bash %}
# work block
_netctl-gui() {}
{% endhighlight %}

Далее, опять, <b>без выделения в отдельную функцию</b> делаем соответствие "функция-команда":

{% highlight bash %}
complete -F _netctl_gui netctl-gui
{% endhighlight %}
</p>

<h2><a name="flags" class="anchor" href="#flags"><span class="octicon octicon-link"></span></a>Флаги</h2>
<p>Как было сказано выше, особого формата тут нет, доступные флаги располагаются просто массивом:

{% highlight bash %}
_netctl_gui_arglist=(
    '-h'
    '--help'
    '-e'
    '--essid'
    '-c'
    '--config'
    '-o'
    '--open'
    '-t'
    '--tab'
    '--set-opts'
)
{% endhighlight %}
</p>

<h2><a name="variables" class="anchor" href="#variables"><span class="octicon octicon-link"></span></a>Массивы переменных</h2>
<p>Приведу только функцию, которая в zsh выглядела таким образом:

{% highlight bash %}
_netctl_profiles() {
    print $(find /etc/netctl -maxdepth 1 -type f -printf "%f\n")
}
{% endhighlight %}

В bash так не получится, пришлось чуть-чуть изменить:

{% highlight bash %}
_netctl_profiles() {
    echo $(find /etc/netctl -maxdepth 1 -type f -printf "%f\n")
}
{% endhighlight %}
</p>

<h2><a name="body" class="anchor" href="#body"><span class="octicon octicon-link"></span></a>Тело функции</h2>
<p>За дополнение в bash отвечает переменная <code>COMPREPLY</code>. Для отслеживания текущего состояния нужно вызвать функцию <code>_get_comp_words_by_ref</code> с параметрами <code>cur</code> (текущая опция) и <code>prev</code> (предыдущая, собственно состояние). Ну и нужно несколько точек, на которых сворачивать в определенную часть case (переменные <code>want*</code>). Для генерации дополнения используется <code>compgen</code>. После флага <code>-W</code> ему подается список слов. (Есть еще флаг <code>-F</code>, который вызывает функцию, но у меня он помимо этого еще и ворнинг выдает.) Последним аргументом идет текущая строка, к которой и нужно генерировать дополнение.</p>

<p>Таким образом, наша функция выглядит так:

{% highlight bash %}
_netctl_gui() {
    COMPREPLY=()
    wantfiles='-@(c|-config)'
    wantprofiles='-@(o|-open|s|-select)'
    wantsettings='-@(-set-opts)'

    wanttabs='-@(t|-tab)'
    _get_comp_words_by_ref cur prev

    if [[ $prev = $wantstring ]]; then
        # не делать дополнения, ждать введенной строки
        COMPREPLY=()
    elif [[ $prev = $wantfiles ]]; then
        # дополнение по существующим файлам
        _filedir
    elif [[ $prev = $wantprofiles ]]; then
        # дополнение из функции
        COMPREPLY=($(compgen -W '${_netctl_profiles[@]}' -- "$cur"))
    elif [[ $prev = $wanttabs ]]; then
        # дополнение из массива
        COMPREPLY=($(compgen -W '${_netctl_gui_tabs[@]}' -- "$cur"))
    elif [[ $prev = $wantsettings ]]; then
        # дополнение из массива
        # -S вставит запятую после, но вот мультивыбор не включил =(
        COMPREPLY=($(compgen -S ',' -W '${_netctl_gui_settings[@]}' -- "$cur"))
    else
        # вывести доступные аргументы
        COMPREPLY=($(compgen -W '${_netctl_gui_arglist[@]}' -- "$cur"))
    fi

    true
}
{% endhighlight %}
</p>

<h2><a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Заключение</h2>
<p>Файл хранится в директории <code>/usr/share/bash-completion/completions/</code> с произвольным именем. Файл примера полностью может быть найден <a href="https://raw.githubusercontent.com/arcan1s/netctl-gui/master/sources/gui/bash-completions">в моем репозитории</a>.</p>
